/**
 * Generates src/services/sharepoint/pdf/embedded-assets.ts
 *
 * Reads font TTF files and logo files from the pdf/fonts and pdf/logos
 * directories and emits them as base64 constants so they are bundled
 * directly into the JavaScript output — no filesystem access at runtime.
 *
 * Usage: bun scripts/generate-pdf-assets.ts
 */

import { readFileSync, writeFileSync, readdirSync } from "fs"
import { join, extname, basename } from "path"

const PDF_DIR = join(
  import.meta.dirname!,
  "..",
  "src",
  "services",
  "sharepoint",
  "pdf",
)
const FONTS_DIR = join(PDF_DIR, "fonts")
const LOGOS_DIR = join(PDF_DIR, "logos")
const OUTPUT = join(PDF_DIR, "embedded-assets.ts")

function toConstName(filename: string): string {
  return filename
    .replace(/\.[^.]+$/, "") // strip extension
    .replace(/[^a-zA-Z0-9]/g, "_") // non-alphanumeric → underscore
    .replace(/_+/g, "_") // collapse multiple underscores
    .toUpperCase()
}

function getMime(filename: string): string {
  const ext = extname(filename).toLowerCase()
  const mimes: Record<string, string> = {
    ".ttf": "font/ttf",
    ".otf": "font/otf",
    ".woff": "font/woff",
    ".woff2": "font/woff2",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".svg": "image/svg+xml",
    ".gif": "image/gif",
    ".webp": "image/webp",
  }
  return mimes[ext] ?? "application/octet-stream"
}

const lines: string[] = [
  "/**",
  " * Auto-generated by scripts/generate-pdf-assets.ts",
  " * Do not edit manually.",
  " */",
  "",
]

// --- Fonts ---
const fontFiles = readdirSync(FONTS_DIR)
  .filter((f) => /\.(ttf|otf|woff2?)$/i.test(f))
  .sort()

lines.push("// Font data as base64-encoded buffers")
for (const file of fontFiles) {
  const b64 = readFileSync(join(FONTS_DIR, file)).toString("base64")
  const name = `FONT_${toConstName(file)}`
  lines.push(`export const ${name} = Buffer.from(`)
  lines.push(`  "${b64}",`)
  lines.push(`  "base64",`)
  lines.push(`)`)
  lines.push("")
}

// Export a typed font map for ABCNormal family
lines.push("export const ABC_NORMAL_FONTS = {")
lines.push("  normal: FONT_ABCNORMAL_NORMAL,")
lines.push("  bold: FONT_ABCNORMAL_MEDIUM,")
lines.push("  italics: FONT_ABCNORMAL_NORMALOBLIQUE,")
lines.push("  bolditalics: FONT_ABCNORMAL_MEDIUMOBLIQUE,")
lines.push("} as const")
lines.push("")

// --- Logos ---
const logoFiles = readdirSync(LOGOS_DIR)
  .filter((f) => /\.(png|jpe?g|svg|gif|webp)$/i.test(f))
  .sort()

lines.push("// Logo data as data URLs")
for (const file of logoFiles) {
  const b64 = readFileSync(join(LOGOS_DIR, file)).toString("base64")
  const mime = getMime(file)
  const name = `LOGO_${toConstName(file)}`

  if (extname(file).toLowerCase() === ".svg") {
    // For SVG, store raw string content (pdfmake uses { svg: string })
    const svgContent = readFileSync(join(LOGOS_DIR, file), "utf-8")
    lines.push(`export const ${name}_SVG = ${JSON.stringify(svgContent)}`)
    lines.push("")
  }

  lines.push(`export const ${name} = "data:${mime};base64,${b64}"`)
  lines.push("")
}

// Export a typed logo map
lines.push("export const LOGOS = {")
for (const file of logoFiles) {
  const name = `LOGO_${toConstName(file)}`
  const key = basename(file)
  if (extname(file).toLowerCase() === ".svg") {
    lines.push(
      `  ${JSON.stringify(key)}: { dataUrl: ${name}, svg: ${name}_SVG },`,
    )
  } else {
    lines.push(`  ${JSON.stringify(key)}: { dataUrl: ${name} },`)
  }
}
lines.push("} as const")
lines.push("")

writeFileSync(OUTPUT, lines.join("\n"))
console.log(`Generated ${OUTPUT}`)
console.log(`  Fonts: ${fontFiles.join(", ")}`)
console.log(`  Logos: ${logoFiles.join(", ")}`)
